    ;; Pegexel is a little exercises generator, using common-lisp.
    ;; Copyright (C) 2012 Yves Combe <yves@ycombe.net>

    ;; This program is free software: you can redistribute it and/or modify
    ;; it under the terms of the GNU Affero General Public License as published by
    ;; the Free Software Foundation, either version 3 of the License, or
    ;; (at your option) any later version.

    ;; This program is distributed in the hope that it will be useful,
    ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
    ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    ;; GNU Affero General Public License for more details.

    ;; You should have received a copy of the GNU Affero General Public License
    ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

(load-files-from-directory *xcvbdir* :type "lisp")

(defun get-description (name &key (command nil) (file-type nil))
  "Get description list for script."
  (unless command (error "Missing command in ~A script~%" name))
  (list name command file-type))

(defun get-extern-script (str stream)
  "Read extern script description and content."
  (let ((description nil)
	(start-pos 0)
	(return-str ""))
    (in-package :template)
    (multiple-value-setq  (description start-pos) (read-from-string str))
    (in-package :script)
    (setq description 
	  (apply #'get-description description))
    (setq  *scripts*
	  (acons (first description)
		 (append (rest  description)
			 (cons (subseq str start-pos)
			       (loop  
				  for line = (read-line stream nil)
				  for pos = (search *end-script* line)
				  while line
				  unless pos collecting line into result
				  when pos collecting (subseq line 0 pos) into result
				  when pos do 
				    (progn 
				      (setq return-str (subseq line (+ pos (length *end-script*))))
				      (return result))
				  finally (return result))))
		 *scripts*))
    return-str))

(defun script-command (key)
  "Get command part of script description"
  (second (assoc key *scripts*)))

(defun script-type (key)
  "Get type part of script description"
  (third (assoc key *scripts*)))

(defun script-content (key)
  "Get content part of script"
  (cdddr (assoc key *scripts*)))

(defparameter *pgxl-begin* "<pg" "Begin part of the pegexel var mark.")
(defparameter *pgxl-end* "xl>" "End part of the pegexel var mark.")

(defun read-in-template (str)
  "read-from-string within template package"
  (in-package :template)
  (let ((result (read-from-string str)))
    (in-package :script)
    result))

(defun replace-pgxl (str)
  "Replace in str all the <pg expr xl>
   by the string output of (eval expr."
    (loop for next-read = 0 then (+ (length *pgxl-end*) begin-end)
       for position = (search *pgxl-begin* str :start2 next-read)
       for end-begin = (when position (+ position (length *pgxl-begin*)))
       for begin-end = (when position (search  *pgxl-end* str :start2 end-begin))
       for pgxl-value = (when position 
			  (if begin-end (subseq  str end-begin begin-end)
			      (error "~A without ~A !" *pgxl-begin* *pgxl-end*)))
       while position
       collecting (subseq  str next-read position) into result
       collecting (format nil "~A" (eval (read-in-template pgxl-value))) into result
       finally (return (apply #'concatenate 'string (append result (list (subseq str next-read)))))))

(defun time-string ()
  "Get date and time in a string YYYY-MM-DD-hh-mm-ss."
  (multiple-value-bind
	(second minute hour date month year day-of-week dst-p tz)
      (get-decoded-time)
    (format nil "~4,'0d-~2,'0d-~2,'0d-~2,'0d-~2,'0d-~2,'0d" year month  date hour minute second)))

(defvar *scripts-files* nil "pList of written script files")


(defun get-files-by-basename (filename)
  "Get all files of the filename's directory
   sharing filename's basename."
  (directory (make-pathname :directory (pathname-directory filename) 
			    :name (pathname-name filename)
			    :type :wild)))

(defun clean-script-file (name)
  "Clean files generated by script name.
   Hope files share basename.
   if *keep-temp-files* is set just output filenames"
  (let ((filename (getf *scripts-files* name)))
    (when filename
      (cond (*keep-temp-files*  (script-output "Not cleaning ~A script file(s):~%"  name)
				(loop for temp-file in (get-files-by-basename filename) 
				   do (script-output "~T~A~%"  temp-file)))
	    (t (script-output "Cleaning ~A script file(s):~%"  name)
	       (loop for temp-file in (get-files-by-basename filename) 
		  do 
		    (script-output "~T~A~%"  temp-file)
		    (delete-file temp-file))))
      (remf *scripts-files* name))))

(defun clean-all-script-files ()
  "Clean all files generated by script part."
  (loop for name  in *scripts-files* when (symbolp name)
       do (clean-script-file name)))

(defun write-if-needed (name)
  "Write file only if necessary.
   In all cases return the filename"
  (or (getf *scripts-files* name)
      (let* ((type (script-type name))
	     (filename (namestring (make-pathname :directory (pathname-directory *filename*) 
						  :name (concatenate 'string 
								     "temp-script-"
								     (time-string))
						  :type type))))
	(script-output "Writing file ~A~%" filename)
	(with-open-file (sc filename :direction :output :if-exists :supersede)
	  (format sc "~{~A~%~}" (mapcar #'replace-pgxl (script-content name))))
	(setf (getf *scripts-files* name) filename)
	filename)))
  

(defun run-script (name  params)
  "Run the script identified by name
   passing params to it.
   Uses run-program/ in xvcd-driver package."
    (let* ((command (script-command name))
	   (filename (write-if-needed name))
	   (run-command (list 'xd:run-program/ `',(append (when command (list command))
							  (list filename) 
							  params)
			      :output :string)))
      (script-output "Running script with command:~%~T~{~A~^ ~}~%" (eval (second run-command)))
      (string-right-trim '(#\Space #\e #\t #\Newline) (eval run-command))))

(export 'run-script)

